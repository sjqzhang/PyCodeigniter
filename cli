#!/usr/bin/python
# -*- coding:utf8 -*-
__author__ = 'xiaozhang'


import shutil,subprocess,time,traceback
import   atexit
from signal import SIGTERM

import os
try:
    import urllib2
except:
    import urllib.request as urllib2
import urllib
import subprocess
import time
import datetime
import re
import logging
import sys
import json
import tempfile
import threading
import getopt
from logging.handlers import RotatingFileHandler
import json
import random


pidfile="/var/zbxcli.pid"
server_url="http://172.17.140.116:8005"
configfile='/etc/cli'

# etcd_prefix='/keeper'

default_module='cli'

bin_name='cli'
client_filename='/bin/%s' % bin_name
client_log_filename= tempfile.gettempdir()+os.path.sep+ bin_name+".log"
client_log_filename= tempfile.gettempdir()+os.path.sep+ bin_name+".log"
script_path= tempfile.gettempdir()+ os.path.sep+'script'


logger = logging.getLogger()
logging.basicConfig(level=logging.DEBUG,
                format='%(asctime)-25s %(module)s:%(lineno)d  %(levelname)-8s %(message)s',
                #datefmt='%a, %d %b %Y %H:%M:%S',
                filename=tempfile.gettempdir()+ os.path.sep +'%s.log' % bin_name,
                filemode='a')
logger.addHandler(RotatingFileHandler(filename=client_log_filename,maxBytes=100 * 1024 * 1024, backupCount=3))

class Daemon(object):
        """
        A generic daemon class.

        Usage: subclass the Daemon class and override the run() method
        """
        def __init__(self, pidfile, stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
                self.stdin = stdin
                self.stdout = stdout
                self.stderr = stderr
                self.pidfile = pidfile

        def daemonize(self):
                """
                do the UNIX double-fork magic, see Stevens' "Advanced
                Programming in the UNIX Environment" for details (ISBN 0201563177)
                http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
                """
                try:
                        pid = os.fork()
                        if pid > 0:
                                # exit first parent
                                sys.exit(0)
                except OSError as  e:
                        sys.stderr.write("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
                        sys.exit(1)

                # decouple from parent environment
                os.chdir("/")
                os.setsid()
                os.umask(0)

                # do second fork
                try:
                        pid = os.fork()
                        if pid > 0:
                                # exit from second parent
                                sys.exit(0)
                except OSError as  e:
                        sys.stderr.write("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
                        sys.exit(1)

                # redirect standard file descriptors
                sys.stdout.flush()
                sys.stderr.flush()
                si = file(self.stdin, 'r')
                so = file(self.stdout, 'a+')
                se = file(self.stderr, 'a+', 0)
                os.dup2(si.fileno(), sys.stdin.fileno())
                os.dup2(so.fileno(), sys.stdout.fileno())
                os.dup2(se.fileno(), sys.stderr.fileno())

                # write pidfile
                atexit.register(self.delpid)
                pid = str(os.getpid())
                file(self.pidfile,'w+').write("%s\n" % pid)

        def delpid(self):
                os.remove(self.pidfile)

        def start(self):
                """
                Start the daemon
                """
                # Check for a pidfile to see if the daemon already runs
                try:
                        pf = file(self.pidfile,'r')
                        pid = int(pf.read().strip())
                        pf.close()
                except IOError:
                        pid = None
                if pid:
                        message = "pidfile %s already exist. Daemon already running?\n"
                        sys.stderr.write(message % self.pidfile)
                        sys.exit(1)

                # Start the daemon
                self.daemonize()
                self.run()

        def stop(self):
                """
                Stop the daemon
                """
                # Get the pid from the pidfile
                try:
                        pf = file(self.pidfile,'r')
                        pid = int(pf.read().strip())
                        pf.close()
                except IOError:
                        pid = None

                if not pid:
                        message = "pidfile %s does not exist. Daemon not running?\n"
                        sys.stderr.write(message % self.pidfile)
                        return # not an error in a restart

                # Try killing the daemon process
                try:
                        while 1:
                                os.kill(pid, SIGTERM)
                                time.sleep(0.1)
                except OSError as  err:
                        err = str(err)
                        if err.find("No such process") > 0:
                                if os.path.exists(self.pidfile):
                                        os.remove(self.pidfile)
                        else:
                                print(str(err))
                                sys.exit(1)

        def restart(self):
                """
                Restart the daemon
                """
                self.stop()
                self.start()


class ZbxCommand(object):
    def __init__(self, cmd):
        self.cmd = cmd
        self.process = None
        self.uuid=str(datetime.datetime.now()).replace(' ','').replace(':','').replace('-','').replace('.','')
        self.result=open(tempfile.gettempdir()+ os.path.sep +self.uuid,'a+')

    def run(self, timeout=30):
        def target():
            logger.info(self.cmd)
            self.process = subprocess.Popen(self.cmd, shell=True,stdout=self.result,stderr=self.result)
            self.process.communicate()
        thread = threading.Thread(target=target)
        thread.start()
        thread.join(timeout)
        if thread.is_alive():
            logger.info(self.cmd)
            self.process.terminate()
            thread.join()
            util=ZbxCommon()
            util.url_fetch(server_url+'/slowlog',{'param':{ 'cmd':self.cmd,'ip':util.get_one_ip()}})
            return "13800138000"
        result= open(tempfile.gettempdir()+ os.path.sep+self.uuid,'r').read()
        os.unlink(tempfile.gettempdir()+ os.path.sep+self.uuid)
        return result


class ZbxCommon(object):
    def urlencode(self,str):
        reprStr=repr(str).replace(r'\x','%')
        return reprStr[1:-1]

    def download(self,filename,directory,filepath):
        try:
            data={'file':filename,'dir':directory}
            data=urllib.urlencode(data)
            http_url='%s/download?%s' % (server_url,data)
            conn = urllib2.urlopen(http_url)
            f = open(filepath,'wb')
            f.write(conn.read())
            f.close()
        except Exception as e:
            logger.error(e)
            print(e)

    def upload(self,url,filepath,directory):
        boundary = '----------%s' % hex(int(time.time() * 1000))
        data = []
        data.append('--%s' % boundary)
        fr=open(filepath,'rb')
        filename=os.path.basename(filepath)
        data.append('Content-Disposition: form-data; name="%s"\r\n' % 'filename')
        data.append(filename)
        data.append('--%s' % boundary)
        data.append('Content-Disposition: form-data; name="%s"\r\n' % 'dir')
        data.append(directory)
        data.append('--%s' % boundary)
        data.append('Content-Disposition: form-data; name="%s"; filename="%s"' % ('file',filename))
        data.append('Content-Type: %s\r\n' % 'image/png')
        data.append(fr.read())
        fr.close()
        data.append('--%s--\r\n' % boundary)

        http_body='\r\n'.join(data)
        try:
            req=urllib2.Request(url, data=http_body)
            req.add_header('Content-Type', 'multipart/form-data; boundary=%s' % boundary)
            req.add_header('User-Agent','Mozilla/5.0')
            req.add_header('Referer','http://remotserver.com/')
            resp = urllib2.urlopen(req, timeout=5)
            qrcont=resp.read()
            print(qrcont)
        except Exception as e:
            logger.error(e)
            print(e)
            print('http error')

    def url_fetch(self,url,data=None,timeout=30,httpCmd='',debug=False):
        html='';
        # print(url)
        home= os.path.expanduser('~')
        fn=home+'/.cli'
        key=''
        if os.path.isfile(fn):
            with open(fn) as f:
                key=f.read().strip()
        try:
            headers = {
                'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6',
                'auth-uuid':key
            }
            if data!=None:
                data=urllib.urlencode(data)
            req = urllib2.Request(
                url =url,
                headers = headers,
                data=data
            )
            if httpCmd != "":
                req.get_method = lambda: httpCmd

            html=urllib2.urlopen(req,timeout=timeout).read()
            charset=re.compile(r'<meta[^>]*charset=[\'\"]*?([a-z0-8\-]+)[\'\"]?[^>]*?>',re.IGNORECASE).findall(html)
            if len(charset) >0:
                if charset[0]=='gb2312':
                    charset[0]='gbk'
                html=unicode(html,charset[0])
            #print(html)
        except Exception as e:
            if debug:
                print("deug", url,data,httpCmd)
            if hasattr(e,'msg'):
                print(e.msg)
            else:
                print(e)

            logger.error(e)
        return html
    def getopt(self,inputs):
        def ptype(input):
            if input == "":
                return (0,"")
            if "-" == input[0] and len(input) == 2:
                return (1,input[1])
            if "--" == input[:2] and len(input) >= 4:
                return (2,input[2:])
            return (0,"")
        def istype(input):
            if len(input) <= 0:
                return 0
            if "-" == input[0]:
                return 1
            return 0
        ret = {}
        ret['__ctrl__']=''
        ret['__func__']=''
        u = 0
        ucount = len(inputs)
        icount = 0
        ls = []
        if ucount >= 1:
            while 1:
                if u >= ucount:
                    break
                if istype(inputs[u]) == 1:
                    break

                ls.append(inputs[u])
                u += 1

            inputs = inputs[u:]
            icount = len(inputs)

        if icount >= 1:
            i = 0
            state = 0
            while 1:
                t,name = ptype(inputs[i])
                for c in range(1):
                    if t == 0 :
                        i += 1
                        break
                    if i+1 < icount:
                        tt,tname = ptype(inputs[i+1])
                        if tt != 0:
                            ret[name] = ""
                            i += 1
                            break
                        ret[name] = inputs[i+1]
                        i += 2
                        break
                    ret[name] = ""
                    i += 1
                    break
                if i >= icount:
                    break
        if len(ls)==2:
            ret['__ctrl__']=ls[0]
            ret['__func__']=ls[1]
        elif len(ls)==1:
            ret['__ctrl__']=''
            ret['__func__']=ls[0]
        return (ret)

    def parse_argv(self,argv):
        data={}
        long_args=[]
        short_args=[]
        for v in argv:
            if v.startswith('--'):
                long_args.append(v.replace('--','')+"=")
            elif v.startswith('-'):
                short_args.append(v.replace('-',''))
        opts= getopt.getopt(argv,":".join(short_args)+":",long_args)
        for opt in opts[0]:
            data[opt[0].replace('-','')]=opt[1]
        if len(data)>0:
            return data
        else:
            return argv



    def now_datetime(self):
        now_datetime = time.strftime('_%Y-%m-%d_%H_%M_%S', time.localtime(time.time()))
        return now_datetime

    def execute(self,cmd):
        try:
            return os.popen(cmd).read()
        except Exception as err:
            logger.error(err)
            return ""


    def get_all_ip_list(self):
        cmdline = "ip a | egrep \"^\s*inet.*\" | grep -v inet6 | awk '{print $2}' | awk -v FS='/' '{print $1}'"
        ret = self.execute(cmdline)
        lip=re.split(r'\n',ret)
        ips=[]
        for ip in lip:
            if str(ip).strip ()!='':
              ips.append(ip.strip())
        return ips


    def get_one_ip(self):
        #ret = [x for x in self.get_all_ip_list() if x.startswith('10') or x.startswith('172') or x.startswith('192')]
        ret = [x for x in self.get_all_ip_list() if x.startswith('10.') or  x.startswith('172.') or  x.startswith('192.') ]
        if len(ret)>1:
            return ret[0]
        return ''.join(ret)

    def get_hostname(self):
        os_name = os.name
        host_name = None
        if os_name == 'nt':
            host_name = os.getenv('computername')
        elif os_name == 'posix':
            host = os.popen('hostname')
            try:
                host_name = host.read().strip()
            finally:
                host.close()
        return host_name


    def exec_filename(self):
        import os, sys, inspect
        path = os.path.realpath(sys.path[0])
        if os.path.isfile(path):
            path = os.path.dirname(path)
            return os.path.abspath(path)+ os.path.sep+__file__
        else:
            caller_file = inspect.stack()[1][1]
            return os.path.abspath(os.path.dirname(caller_file))+ os.path.sep+__file__



    def tuple2list(self,*args):
        print(args)
        l=[]
        for i in args:
            l.append(i)
        return l

    def command_args(self,args):
        if isinstance(args,list) or isinstance(args,tuple):
            return '"%s"' % '" "'.join(args)
        else:
            return str(args)





class ZbxCli():


    def __init__(self,default_module):
        self.entry=server_url+'/'+default_module+"/%s"
        self.util=ZbxCommon()
        # self.etcd_prefix=etcd_prefix


    def download(self,args):
        argv= self.util.parse_argv(args)
        if isinstance(argv,list):
            argv={}
        if 'f' in argv.keys():
            f=argv['f']
        else:
            return '(error) -f(filename) require'
        if 'd' not in argv:
            argv['d']='/'
        if 'o' not in argv:
            argv['o']=argv['f']
        self.util.download(argv['f'],argv['d'],argv['o'])

    def upload(self,args):
        argv= self.util.parse_argv(args)
        if isinstance(argv,list):
            argv={}
        if 'f' in argv.keys():
            f=argv['f']
        else:
            return '(error) -f(filename) require'
        if 'd' not in argv:
            argv['d']='/'
        self.util.upload(self.entry%"upload", argv['f'],argv['d'])

    def help(self,args):
        ret=self.util.url_fetch(self.entry%'help')
        print(ret)

    def upgrade(self,args):
        fn=self.util.exec_filename()
        content=self.util.url_fetch(self.entry%'upgrade')
        if content!='':
            open('/tmp/cli','w').write(content)
            os.system('chmod +x /tmp/cli')
            os.system('mv -f /tmp/cli %s' %(client_filename))
            print('success')
        else:
            print('fail')
    def adddoc(self,args):
        argv=self.util.getopt(args)
        if 'f' in argv:
            argv['d']=open(argv['f'],'r').read()

        ret=self.util.url_fetch(self.entry%'adddoc',{'param':json.dumps(argv)})
        print(ret)

    def daemon(self,argv):
        daemon = ZbxDaemon(pidfile)
        setattr(daemon,'zbxcli',self)
        data= self.util.getopt(sys.argv[1:])
        opt = data.get('s')
        if 'start' == opt:
            print("cli daemon start")
            daemon.start()
        elif 'stop' == opt:
            print("cli daemon stop")
            daemon.stop()
        elif 'restart' == opt:
            print("cli daemon restart")
            daemon.restart()
        elif 'debug' == opt:
            print("cli daemon debug")
            daemon.run()
        else:
            print("usage: cli deamon -s start|stop|restart")
            sys.exit(2)
        sys.exit(0)

    def logout(self,argv):
        home= os.path.expanduser('~')
        fn=home+'/.cli'
        if os.path.isfile(fn):
            with open(fn,"w") as f:
                f.write('')
    def register(self,argv):
        data= self.util.getopt(sys.argv[1:])
        if 'u' not in data:
            data['u']=raw_input('please input username: ')
        if 'p' not in data:
            import getpass
            data['p']=getpass.getpass('please input password: ')
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(data)})
        print(ret)

    def login(self,argv):
        data= self.util.getopt(sys.argv[1:])
        if 'u' not in data:
            data['u']=raw_input('please input username: ')
        if 'p' not in data:
            import getpass
            data['p']=getpass.getpass('please input password: ')
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(data)})
        home= os.path.expanduser('~')
        fn=home+'/.cli'
        # if os.path.isfile(fn):
        with open(fn,"w") as f:
            f.write(ret)
            if len(ret)==36:
                print('success')
                return
            else:
                print(ret)
                return
        print(ret)

    def config(self,argv):
        conf='''
pidfile=/var/zbxcli.pid
server_url=http://127.0.0.1:8005
'''
        with open(configfile,'w') as f:
            f.write(conf)

    def default(self,module,action,args):
        #argv= self.util.parse_argv(args)
        argv=self.util.getopt(args)
        if isinstance(argv,list):
            argv={}
        if isinstance(argv,dict):
            if not 's' in argv:
                argv['s']=self.util.get_hostname()
            if not 'i' in argv:
                argv['i']=self.util.get_one_ip()
            #if not 'g' in argv:
            #    argv['g']="Discovered hosts"
            #if not 't' in argv:
            #    argv['t']="Meizu-System"
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(argv)})
        print(ret)
        return ret

    def remote_server(self,module,action,argv):
        if isinstance(argv,dict):
            if not 's' in argv:
                argv['s']=self.util.get_hostname()
            if not 'i' in argv:
                argv['i']=self.util.get_one_ip()
            #if not 'g' in argv:
            #    argv['g']="Discovered hosts"
            #if not 't' in argv:
            #    argv['t']="Meizu-System"
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(argv)})
        return ret

    def shell(self,args):
        if len(args)<1:
            print('ERROR: param is not enough')
            sys.exit(0)

        #path=tempfile.gettempdir()+os.sep+'zbxcli';
        filename=''
        argv= self.util.parse_argv(args)
        if 'f' in argv.keys():
            filename=argv['f']
        else:
            return '(error) -f(filename) require'
        path=script_path
        if not os.path.exists(path):
            self.util.execute('mkdir -p %s'%path)

        fn=path+os.path.sep+filename
        src=''
        is_python=False
        result=-1
        if not os.path.exists(fn) or os.stat(fn).st_mtime<(time.time()-10*60):
            src=self.util.url_fetch(self.entry%'shell',{ 'file':filename, 'param': json.dumps(args[1:])},timeout=60*60)
        if src!='':
            open(fn,'w').write(src)
        else:
            src=open(fn,'r').read()

        lines=re.split(r'\n',src)
        for line in lines:
            if line.strip()!='':
                break;
        if line.find('python')>0:
                is_python=True
        if is_python:
            cmd=ZbxCommand('/usr/bin/python %s %s'% (fn,self.util.command_args(args[1:])))
            result=cmd.run(60*60*24)
        else:
            cmd=ZbxCommand('/bin/bash %s %s'% (fn,self.util.command_args(args[1:])))
            result=cmd.run(60*60*24)
        print(result)

class ZbxDaemon(Daemon):



    def __getattr__(self,attr):
        if hasattr(self,'zbxcli'):
            if hasattr(self.zbxcli,attr):
                return getattr(self.zbxcli,attr)
        return None

    def get_etcd(self):
        try:
            now = time.time()
            if now - self.update_time > 600:
                print("=== get etcd")
                self.etcd_conf =  json.loads(self.remote_server('cli','getetcd',{}) )
                print(self.etcd_conf)
                self.etcd_list=self.etcd_conf['server']
                self.etcd_prefix=self.etcd_conf['prefix']
                if not isinstance(self.etcd_list,list):
                    raise Exception("get etcd list error")
                for host in self.etcd_list:
                    print(self.util.url_fetch("http://%s/v2/keys%s/heartbeat" % (host,self.etcd_prefix) ,data={'ttl':60,'value':'heartbeat'},httpCmd = 'PUT' ))
                    print(self.util.url_fetch("http://%s/v2/keys%s/servers" % (host,self.etcd_prefix) ,data={'ttl':60,'value':'servers'},httpCmd = 'PUT' ))
                self.update_time = now
        except Exception as er:
            print(er)
            time.sleep(5)
            return self.get_etcd()



    def heartbeat(self):
        try:
            print("=== heartbeat start")
            ip = self.util.get_one_ip()
            for host in self.etcd_list:
                print("heartbeat:  http://%s/v2/keys%s/heartbeat/%s" % (host,self.etcd_prefix,ip))
                html = self.util.url_fetch("http://%s/v2/keys%s/heartbeat/%s" % (host,self.etcd_prefix,ip) ,data={'ttl':60,'value':'2333'},httpCmd = 'PUT' )
                if html != "":
                    break
            print("=== heartbeata end")
        except Exception as er:
            print(er)
            logger.error('heartbeat error:'+str(er))


    def watch_commmand(self):
        try:
            ip = self.util.get_one_ip()
            print("watch_commmand",ip,self.etcd_list)
            for host in self.etcd_list:
                self.util.url_fetch("http://%s/v2/keys%s/servers/%s?wait=true&recursive=true" % (host,self.etcd_prefix,ip),timeout = 20+ random.randint(1,10) )
                content = self.util.url_fetch("http://%s/v2/keys%s/servers/%s?recursive=true" % (host,self.etcd_prefix,ip),timeout = 10 )
                print("content   "+content)
                if content != "":
                    self.feedback_result(ip,host,content)
                    break
        except Exception as er:
            print(er)
            logger.error('watch_commmand error:'+str(er))







    def feedback_result(self,ip,host,content):
        try:
            print("process cmd")
            if content == "Not Found":
                print("no found key")
                return
            rjson = json.loads(content)
            if not rjson['node'].get('dir',False):
                url = "http://%s/v2/keys%s?recursive=true" % (host,rjson['node']['key'])
                print("feedback_result"+ url)
                self.util.url_fetch(url,httpCmd= 'DELETE' )
                print("publish is no dir")
                return

            if not rjson['node'].get('nodes'):
                print("no found command")
                return

            for cNode in  rjson['node']['nodes']:
                cmd = cNode['value'].encode("utf-8")
                key = cNode['key']
                createdIndex = cNode['createdIndex']
                # self.keys.append(key)
                url = "http://%s/v2/keys%s?recursive=true" % (host,key)
                self.util.url_fetch(url,httpCmd= 'DELETE' )
                def tmp():
                    result = ZbxCommand(cmd).run()
                    print(type(result))
                    message = {'ip':ip, 'cmd':cmd, 'result':result,'index':createdIndex}
                    print(message)
                    self.remote_server('cli','feedback_result',{'param':message})
                threading.Thread(target=tmp).start()


        except BaseException as e:
            logger.error('feedback_result error:'+str(e))
            print("feed error")
            print(e)




    def run(self):
        self.update_time=time.time()-800

        while True:
            try:
                self.get_etcd()
                self.heartbeat()
                self.watch_commmand()
                time.sleep(1)
            except BaseException as e:
                pass
                time.sleep(5)


if __name__ == '__main__':
    if os.path.isfile(configfile):
        with open(configfile) as f:
            try:
                for l in f.read().strip().split("\n"):
                    k,v=l.split('=',1)
                    if k.strip()=='server_url' and v!='':
                        server_url=v.strip()
                    if k.strip()=='pidfile' and v!='':
                        pidfile=v.strip()
            except Exception as er:
                logger.error(er)
                pass

    module=default_module
    action='help'
    cli=ZbxCli(default_module)
    util=ZbxCommon()
    data= util.getopt(sys.argv[1:])


    if data['__ctrl__']=='':
        if data['__func__']=='':
            action='help'
        else:
            action=data['__func__']
    else:
        module=data['__ctrl__']
        action=data['__func__']
    if hasattr(cli,action):
       getattr(cli,action)(sys.argv[2:])
    else:
       cli.default(module,action,sys.argv[1:])

    #if len(sys.argv)<2:
    #    cli.help(sys.argv)
    #    sys.exit(0)
    #elif (len(sys.argv)==2) or (len(sys.argv)>2 and sys.argv[2].startswith('-')):
    #    action=sys.argv[1]
    #elif len(sys.argv)>2 and not sys.argv[2].startswith('-'):
    #    module=sys.argv[1]
    #    action=sys.argv[2]
    #elif len(sys.argv)>2 :
    #    module=sys.argv[1]
    #    action=sys.argv[2]
    #if hasattr(cli,action):
    #   getattr(cli,action)(sys.argv[2:])
    #else:
    #   cli.default(module,action,sys.argv[2:])







